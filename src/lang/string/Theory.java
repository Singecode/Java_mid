package lang.string;

public class Theory {
    //문자 하나를 저장할때는 char.
    //문자 하나를 여러개를 만들어서 문장처럼 출력하고 싶다? == char배열 선언.
    //그러나 char배열은 쓰기 번거로우므로 우리는 문자열을 출력하고자 할때 String을 사용

    //String을 통해 문자열을 생성하는 방법
    // 1. " 이용 -> String str1 = "hello";
    // 2. new 이용 -> String str2 = new String("hello");
    // String은 기본형이 아닌 참조형임.
    // str1은 String인스턴스의 참조값만 들어감.
    // 그래서 new를 통한 참조값 저장이 좀더 바람직한 방법으로 보임.
    // 그러나 Strnig은 자바에서 매우 자주 사용된는 타입임.
    // 따라사 우리가 그냥 "로 감싸주기만 하면 자바에서 알아서 new String("~")와 같은 형태로 변환해줌.

//    public final class String {
//        //문자열 보관
//        private final char[] value;// 자바 9 이전
//        private final byte[] value;// 자바 9 이후
//        //여러 메서드
//        public String concat(String str) {...}
//        public int length() {...}
//    ...
//    }

    //String 클래스의 대략적인 모습임.
    // private final char[] value; -> 여기에 실제 String의 문자값이 저장되는 구조이다.
    // 문자 데이터 자체는 char[]에 저장. 직접 다루기 불편한 char[]을 감추고
    // String 클래스를 사용하는 개발자가 편리하게 문자열을 다룰 수 있도록 다양한 기능을 제공,
    // 메서드 제공을 넘어서 자바 언어 차원에서도 여러 편의 문법 제공.
    // *참고 자바 9이상에서는 char[]대신 byte[]을 사용
    // ->char은 2byte차지 그러나 영어 숫자는 = 1byte로 표현이 가능함.
    // 이렇게 함으로써 메모리를 좀더 효율적으로 사용할 수 있게 됨.

    //String은 클래스 ==> 참조형 --> 때문에 원칙적으로 둘의 + 연산은 지원하지 않아야 함.
    //그러나 String은 너무 자주 쓰이기 때문에 특별하게 +연산을 지원해줌
    //원래는 2개의 문자열의 합칠때는, concat을 이용해야하지만, 예외적으로 자바에서는 +연산도 지원해줌.
    //그래서 concat의 연산결과와 +한 값의 결과가 같게 나옴 (StringConcatMain)참조.

    //String 클래스 비교..
    //String 클래스는 비교할때 == 연산이아니라 equals연산을 해줘야 함.
    //리터럴 과 String 객체 생성 비교
    // new String(~)을 통해 생성산 String 클래스 비교시 == 연산은 false, equals연산은 true로 나옴..
    // 자바에서는 이미 String 클래스 내에서 equals를 오버라이딩 시켜놓은 그래서 equals는 true값..
    // ==연산은 인스턴스 생성 시점에서 당연해 둘은 서로 다른 참조값을 지니기때문에 false.

    // 리터럴 비교 String str1 = "~"; 시 == 연산 equals연산 둘다 true로 나옴..
    // equals가 true가 나오는데는 이견이 없지만, == ?
    // String pool 덕분, 여기서 Pool은 자원이 모여있는 곳을 의미 String str3 = "hello"를 생성 했다면
    // pool은 자바가 실행되는 시점에 String 인스턴스를 풀에 미리 만들어 놓음
    // 따라서 문자열 리터럴을 사용하면 풀에서 미리 만들어놓은 인스턴스를 찾고, 해당 참조를 반환
    // 만약 str4 = "hello"; 라면 자바는 pool에서 hello를 찾고 참조를 반환함 -> 이미 생성된 인스턴스는 중복해서 만들지 않음.
    // 문자열 풀 덕분에 문자를 사용하는 경우 메모리 사용을 줄이고, 문자를 만드는 시간돌 줄어들기 때문에 성능도 올라감.
    // 참고로 문자열 풀은 힙영역 사용, 문자를 찾을때는 해시 알고리즘을 적용 O(1)와 같은 매우 빠른 속도록 원하는 문자열을
    // 찾을 수 있음.

    // 문자열 리터럴을 사용하면 ==비교, new String을 사용하는 경우 equals()를 나눠 각각 이렇게 사용하면 되는거 아닌가?
    // ->(StringEqualsMain2) 참조.

    // String은 불변 객체임
    // 따라서 생성 이후에 절대로 내부의 문자열 값을 변경할 수 없음.
    // (immutable)패키지 참조.

    //Sting 클래스의 주요 메서드 *자주 사용하는 메서드 위주
    //기능이 너무 많기 때문에 내가 모든 메서드를 외우는 것 보다는 이렇게 사용하는구나를 인지하고 필요할때 api 문서를 통해
    //찾는 것이 바람직함.

    //가변 String
    //불변 String의 단점 ==> String의 내부값은 변경할 수 없으므로.
    //문자열을 더하거나 변경할때마다 새로운 객체가 계속 생성됨.
    //시스템의 자원을 많이 소비하게 됨.
    // 이런 문제를 해결하는 방법은 불변이 아닌 가변 String 클래스가 존재하면 됨.
    // 가변은 내부의 값을 바로 변경하면 되기때문에 성능과 메모리 사용에서 불변보다 더 효율적..
    // StringBuilder. 물론 가변의 경우 사이드 이펙트를 조심해야함.
    // StringBulider는 내부 필드에 final이 아닌 가변의 값이 있음
    // StringBuilder를 활용해서 보통 문자열을 변경하는 동안만 사용하다가 문자열 변경이 끝나면
    // 불변 String으로 변환해서 사용하는 것이 좋음.

    //String 최적화
    // 컴파일 전 String str1 = "Hello" String str2 = "World";
    //컴파일 후 == Hello World
    // 런타임에서 별도의 문자열 결합 연산을 수행하지 않기 때문에 성능이 향상.

    // 문자열 변수의 경우 String st1, String str2
    // String result = str1+str2;
    // 컴파일 시점에서는 그 안에 어떤값이 들어있는지 모르기 때문에 단순히 합칠 수 없음.
    //String result = new StringBuilder().append(str1).append(str2).toString(); -> 이런식으로 작동.
//    참고: 자바 9부터는
//    StringConcatFactory
//    를 사용해서 최적화를 수행한다
    // String 최적화가 어려운 경우 == 문자열을 루프안에서 더하는 경우 최적화가 이뤄지지 않음.
    // 이는 결국 반복횟수 만큼 객체를 생성하게 됨.

    // 문자열을 합칠때는 대부분 최적화가 되므로 그냥 +연산을 사용하면 됨.
    // 그러나 StringBuilder를 직접 사용하는 것이 더 좋은 경우?
    // 1.반복문에서 문자를 연결할때
    // 2.조건문을 통해 동적으로 문자열을 연결할때
    // 3.복잡한 문자열의 특정 부분을 변경할때
    // 4.매운 긴 문자열을 다룰때

    //메서드 체이닝
    //자기 자신의 참조값 반환 return this;
    //참조값이 같다면 자기자신의 메서드를 변수의 지속적인 선언없이 .을 통해 연속적으로 접근 가능
    //ex. 메이플의 체인라이트닝 스킬 생각.
    //StringBuilder에서 또한 이러한 메서드 체이닝을 제공
}
